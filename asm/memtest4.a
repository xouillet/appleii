; MCS 6502 MEMORY TEST
;
	!cpu 6502
	!set apple2 = 1
;	!set apple1 = 1
!ifdef apple1 {
	!to "a1mt.txt"   	;output file in apple command format
}
!ifdef apple2 {
	!to "a2mt.txt"   	;output file in apple command format
}
; MACROS
;
; INITIALIZE ADDRESS WITH START
	!macro INI_ADDRS {	
	LDA START
        STA ADDRS
        LDA START + $01
        STA ADDRS + $01
}

; INCREMENT ADDRESS
	!macro INC_ADDRSC {
	INC ADDRS
	BNE .SKIP_HI
	INC ADDRS+$01
 .SKIP_HI
	LDA END
	CMP ADDRS
	BNE .EXIT2
	LDA END+$01
	CMP ADDRS+$01
 .EXIT2
}

; SET TEST PATTERN
; only for tests 4 and 5 (address in address tests), make addres High or Low 
; equal to pattern
; test 4 is LSB of address
; test 5 is MSB of address
; 
	!macro 	SET_PATRN 	{
	CPY	#4
	BNE 	.TEST5
	LDA	ADDRS
	STA	TEST_PATRN 
.TEST5
	CPY	#5
	BNE 	.EXIT1
	LDA	ADDRS+$01
	STA	TEST_PATRN 
.EXIT1	
}

; ZERO PAGE LOCATIONS
	*=$0
!ifdef apple2 {
START     !byte $0,$0a 	;USER ENTERS START OF MEMORY RANGE min is 38
END       !byte $0,$40 	;USER ENTERS END OF MEMORY RANGE
} 
!ifdef apple1 {
START     !byte $0,$5 	;USER ENTERS START OF MEMORY RANGE min is 8
END       !byte $0,$10  ;USER ENTERS END OF MEMORY RANGE
}
ADDRS 	!byte $0,$0		; 2 BYTES - ADDRESS OF MEMORY
TEST_PATRN 	!byte 0      	; 1 BYTE - CURRENT TEST PATTERN
PASSES       !byte $0 ;NUMBER of PASSES
;
; start of program
; start at $800 for apple 2
!ifdef apple2 {
	*=$800
}
; start at $280 for apple 1
!ifdef apple1 {
	*=$280
}
; TESTS TYPE
;	0 = all zeros
;	1 = all ones
;	2 = floating 1s
;	3 = floating 0s
;	4 = address in address (LS 8 address bits)
;	5 = adddress in address(MS 8 address bits)
;

MEM_TEST 
	LDA #$00
	STA	PASSES		; start at pass 0
REPEAT
	LDA #$00
	TAY			; TEST # in REG Y
	TAX			; X must be zero
	STA TEST_PATRN   	; first pass all zeros
;
NX_PASS
	+INI_ADDRS
;
LOOP1
	+SET_PATRN		; sets up TEST_PATRN for address in address test
	LDA	TEST_PATRN
	STA 	(ADDRS, X) 	; STORE PATTERN
	LDA 	(ADDRS, X) 	; READ (save result of read in case of error)
	CMP	TEST_PATRN	; CHECK
	BNE 	LOOP_ERR2 	; branch if error
	+INC_ADDRSC
	BNE 	LOOP1
;
CK_PATRN 
	+INI_ADDRS 	; INITIALISE ADDRS
;
LOOP2	
	+SET_PATRN		; sets up TEST_PATRN for address in address test
	LDA 	(ADDRS, X) 	; READ  (save result of read in case of error)
	CMP	TEST_PATRN	; CHECK
LOOP_ERR2
	BNE 	LOOP_ERR	; branch if error
	+INC_ADDRSC
	BNE LOOP2
;
; Pass Complete - see what is next
;
	CPY	#0		; test 0 - all zeros complete
	BNE	CHK_TEST1
;
; move to test 1
;

	LDA	#$ff		; 
NX_TEST
	STA	TEST_PATRN
	INY			; move to next test 
NX_PASS3
NX_PASS1
NX_PASS2
	JMP	NX_PASS
	
;
; 
;
CHK_TEST1
	CPY	#1		; all ones complete?
	BNE	CHK_TEST2
;
; test 1 - all zeros comlete
;
	LDA	#$01
	BNE	NX_TEST	; always

CHK_TEST2
	CPY	#2		; floating 1s in progress or done
	BNE	CHK_TEST3
;
; pass of test 2 complete - 8 passes in all with 1 in each bit position
;
	ASL 	TEST_PATRN		; shift left - zero to LSB- MSB to CARRY
	BCC	NX_PASS1
;
; all test 2 passes complete - prepase for test 3
;
	LDA	#$7F
	BNE	NX_TEST		;always branch

CHK_TEST3		;floating zeros in progress or done
	CPY	#3
	BNE	CHK_TEST4
;
; pass of test 3 complete - 8 passes in all with 0 in each bit position
;
	SEC			
	ROR	TEST_PATRN	; rotate right - Carry to MSB, LSB to Carry
	BCS	NX_PASS2	; keep going until zero bit reaches carry

NXT_ADDR_TEST
	INY			; move to test 4 or 5 - address in address
	BNE	NX_PASS3	; aways
;
; ADDRESS IN ADDRESS tests - two test only make one pass each
;
CHK_TEST4
	CPY	#4		; address in address (low done)?
	BEQ	NXT_ADDR_TEST	; if test 4 done, start test 5

; test 5 complete - we have finished a complete pass
TESTDONE			; print done and stop
	LDA	#'P'
	JSR	WRITE
	LDA	#'A'
	JSR	WRITE
	LDA	#'S'
	JSR	WRITE
	LDA	#'S'
	JSR	WRITE
    	JSR	SPACE
	INC	PASSES
	LDA	PASSES
	JSR	TBYT
	JSR	PRINT_CRLF
	nop
	nop
	nop	
	jmp	REPEAT

; OUTPUT THE ERROR INFO and STOP	
; TEST#, ADDRESS, PATTERN, ERROR
LOOP_ERR

	PHA
	TYA			; test # is in Y
	JSR	TBYT 		; test #
    	JSR	SPACE
	LDA ADDRS + $01
	JSR	TBYT 		; OUTPUT ADDRS HI
	LDA ADDRS
	JSR	TBYT 		; OUTPUT ADDRS LO
      	JSR	SPACE
      	LDA 	TEST_PATRN
      	JSR	TBYT 		; OUTPUT EXPECTED
      JSR	SPACE
	PLA
      JSR	TBYT 		; OUTPUT ACTUAL
      JSR	PRINT_CRLF

FINISHED
!ifdef apple2 {
;
; apple II brk
;
	brk
	nop
	nop
}
!ifdef apple1 {

;
; apple 1
;
	jmp	$FF00
}


; ROUTINE TO WRITE AN ASCII CHAR.
;ROM_LINK change to character out routine for your platform
WRITE

!ifdef apple2 {
; Apple II version here
	ORA	#$80   
	JSR	$fdf0
}

!ifdef apple1 {
; Apple 1 version here
	JSR	$FFEF
}
	RTS

; PRINT HEX BYTE
TBYT
   	PHA
	LSR
	LSR
	LSR
	LSR
	AND 	#$0F
	ORA 	#$30	
	CMP 	#$3A
	BCC 	WRT
	ADC 	#$06
WRT
	JSR	WRITE
      PLA
	AND 	#$0F
      ORA 	#$30
      CMP 	#$3A
	BCC 	WRT2
	ADC 	#$06
WRT2
	JSR	WRITE
	RTS

PRINT_CRLF
; ROUTINE TO OUTPUT CRLF
	LDA 	#$0D
	JSR	WRITE
	LDA 	#$0A
      JSR	WRITE
	RTS


; SPACE = OUTPUT 1 SPACE
SPACE
	LDA 	#' '
	JSR	WRITE
	RTS


END_PGM
